---
title: 微机寻址相关
---

# 微机寻址操作的对象

### 🐷前期铺垫：

* (AX)表示取AX的内容

* [AX]表示取AX内容作为地址



我把可能操作的对象都列出来了：

![](https://i.loli.net/2020/10/10/hFTlfK6onGuE1q2.png)

长条的代表是16位寄存器，短条代表的是8位。

❗**第一条法则：数据类型要匹配**

**小的数据、内容可以放进长的容器，但大的数据的不能放进短的容器。**很好理解吧？数据、内容的大小指的是8位、16位。在8086里我们主要是这两种，其他如80386以上的微机可以有32位的。

**❗第二条法则：操作命令要符合语法**

以我们最常见的MOV指令为例，给出MOV指令的操作对象关系：

![](https://i.loli.net/2020/10/10/LCky9uerxvJ7SaR.jpg)

MOV指令一共有两个操作数部分，左边的操作数叫**目的操作数**，右边的操作数叫做源操作数。

通过这张表我们可以知道，合法的操作包含这几种情况：



* ❗立即数**不能**传输给段寄存器
* ❗只有通用寄存器之间才能相互传输
* ❗立即数不能作为目的操作数（目的操作数可以是地址）



### 微机寻址方式

* 固定寻址
* 立即数寻址
* 寄存器寻址
* 存储器寻址
* I/O端口寻址

前三种有手就行，重点在第四种存储器寻址。

存储器寻址有6种方式，常用的5种，他们的顺序是层层递进的，前面的方法都可以在后面用到。

**我们可以用高级语言的函数与形参的思维来理解、分辨他们。**



#### 直接寻址（1立即）

```assembly
MOV AL,[2000H];   --将(DS)*16+2000H存储单元的内容传输给AL。
```

如果出现了操作数地址位于数据DS段外，则可以加上前缀表示**段前超越**：

```assembly
MOV AL,ES:[2000H];  --将ES中偏移地址为2000H的字节二单元内容传输打到AL
```

因为间接寻址归DS管所以用的是(DS)；如果是其他寻址方式则要用对应的段。



#### 寄存器间接寻址（1寄存）

先来看两个可能会出现混淆的代码：

```assembly
MOV AX,[BP];  
MOV [BP],AX; 
```

第一行表示将以(SS)*16+BP为地址的存储单元传输至AX中。

第二行表示将AX内容传输至以(SS)*16+BP为地址的存储单元。

用人话来说就是第一个是给AX赋值，第二个是代表的存储单元赋值。



对比上一种方式，这种方式没把数字直白的表现出来，而是含蓄的暂存在**通用寄存器中**。BP作为通用寄存器，其通用性就体现在它可以作为一个中转站，为不能赋值的寄存器提供中转。



#### 寄存器相对寻址(1立即，1寄存)

```assembly
MOV AX,[SI+06H];  -- 将(DS)*16+(SI)+06H作为地址的存储单元的内容赋值给AX
MOV AX,[SI]06H;
MOV AX,06H[SI];  --这三条其实是一样的
```

对比上一条，多了一个立即数。这个立即数可以非常灵活的变动，所以这种寻址方式很适合访问数组（就是一个一元表格，有若干元素）。



#### 基址变址寻址（2寄存）

```assembly
MOV AX,[BX][SI];	--将以(DS)*16+[BX]+[SI]作为地址的存储单元的内容传输给AX
MOV AX,[BX+SI];
MOV AX,DS:[BP][DI];	--将以(SS)*16+[BP]+[DI]作为地址的存储单元的内容传输给AX
```

以上都是对的。**BX、BP为一组，DI、SI为一组，要从这两组中各选一个做为参数。**



#### 相对基址加变址寻址（2寄存1立即）

```assembly
MOV AX,[BX][DI]06H;		--将以(SS)*16+[BP]+[DI]+06H作为地址的存储单元的内容传输给AX
MOV AX,[BX][DI]DATA;    --DATA是一个变量，提前赋值过了
```





**发现了吗，其实我们在乎的不是寻址的方式，而是寻址的语法。**我们关注的是我们的数据如何成功的从一个存储器或者寄存器流动到另一个去，实现的方式，也就是我们的寻址方式；我们关注能否成功不在于寻址方式有多花里胡哨， 而在于语法正不正去、适不适用。