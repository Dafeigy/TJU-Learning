---
title: 单片机程序结构 笔记
mathjax: true
---



单片机程序我也是服了，这年头谁他妈用汇编啊？

赵岩奶奶也对我们太有信心了吧？

现在好啦要他妈自学汇编语言真有你的天津自学大学👎

## 1.汇编程序的一些规则

汇编语言是一种应该和c++、拉丁语一起在坟墓里**发烂发臭**的语言💀。它的存在意义只是让你的大脑被无用的知识占用更多空间。

汇编的本质是将汇编语言程序到机器语言程序的转换。一般我们说的汇编是指机器汇编，但它却遵循一些很符合常规的需求（和c++类似）：

##### 1.基础数据类型的表示：

| 数据类型   | 示例       |
| ---------- | ---------- |
| 十进制数   | 20，20D    |
| 十六进制数 | 87H,0F0H   |
| 二进制数   | 010110011B |
| 字符       | ‘H‘        |
| 字符串     | "Hello"    |

##### 2.伪指令：

伪指令是一种没有指令代码的指令。简单来说就是一个方便汇编语言它自己编译的一个注释段。反正我们不关注这一部分。

几种常用的伪指令：

| 指令名称 | 作用                               |
| -------- | ---------------------------------- |
| ORG      | 起始地址指令，程序或数据的起始地址 |
| DB       | 定义字节常数指令                   |
| DW       | 定义字型常数指令                   |
| EQU      | 等值指令。为标号或标识符赋值。     |
| END      | 结束汇编指令。                     |



看到这里也很懵吧？懵逼就对啦！因为老子也不懂！这些东西有什么鬼用啊！

**我想先总结下一些规律：**

**1.累加器A是万金油，基本上所有指令方式都可以与A操作。**

**2.汇编语言虽然是一门应该死掉的语言，但是它的指令执行是并行的。用人话说就是他不是顺序执行，可以在几个代码块里面反复横跳。**（子程序思想）

**3.汇编语言的复杂我个人感觉不是在指令的繁多，而是对“指针”、“地址”、“内容” 这三者和变量容器的联系与应用。**



## 2.汇编程序常用程序结构

####  🎉2.1直线结构

简单来说就是一条路走到黑。

```assembly
MOV A, #56H ;A存放BCD码56H 
MOV B,#17H ;B存放BCD码17H 
ADD A, B ;A=6dH 
DA  A ;A=73H  DA是BCD调整，用来把计算机用十进制BCD码算出来的二进制结果转成十进制的
SJMP $
```

这个程序就是用来算56+17的 .



#### 🎀2.2 分支结构

也就是满足某一条件走一条路；满足另一条件走另一条路。

以这个例子作为示范：

🌰**每10KG为一个计价单位G存入了40H单元。（G比较小，保证运算不会溢出）。行李费用计算是这样的：当G<=5时，M=G*3;当G>5时，M=G\*3+(G-3)\*(5-3).**

```assembly
FRT:MOV A,40H;			把计价单位G取出放入A
	MOV R3,A;			暂存A
	MOV B,#03H; 		运费计算中的*3中的“3”
	MUL AB;				运费M=G*3，这里因为G比较小所以B里面没有内容，如果乘积打羽255H，则内容会先把低字节放入A，高字节放入B
	MOV R2,A;			把计算结果存入R2
	MOV A,R3;			重新取回G
	CJNE A,#05H,L1; 	CJNE是数值比较转移指令，A和#05H相等的话就不转移继续执行下一行，不相等的话就转移到L1；同时会对CY进行重新赋值，如果左边操作							数大于右边操作数，则CY=0；左边操作数小于右边操作数时，CY=1.
	SJMP WETC;			转移到WETC段
L1: JC WETC;			JC是CY为1时的转移指令，当CY=1时转移到WETC。这里其实是对CJNE的一个伏笔的回收，其实是一个二段转移。
	SUBB A,05#;			将A-5，用来准备计算2*（G-5)的部分
	RLC A;				RLC是移位指令，是将A中8位数的每一位左移，同时将最后一位补上1.在二进制数左移一位其实就是*2，这里有炫技嫌疑我觉得很无聊
	ADD A,R2;			不用我多说了吧？			
	MOV R2,A;			不用多说了吧？
WETC:MOV 41H,R2;		把最终结果存放到41H
	RET
```



#### 💡2.3 循环结构

这不用我说了吧？值得注意的点就是它的基本结构：

①初始化：循环准备工作，比如清空结果单元，设数据指针、循环控制变量的初值。

②循环体：由两部分，一部分是工作部分，一部分是控制数据指针部分（要不就会原地TP）。

③结束：处理和保存循环结果。

我们先来一个简单的例子：

🌰**求n个单字节数据的累加，设数据串已经在43H起始单元，数据串长度在42H，且累加和不超过两个字节**。

即：

| RAM地址 | RAM内容 |
| :-----: | :-----: |
|   ...   |   ...   |
|   ...   |   X_n   |
|   ...   |   ...   |
|   43H   |   X1    |
|   42H   |    n    |
|   41H   |  SUM_H  |
|   40H   |  SUM_L  |



```assembly
SUM: MOV R0,#42H;	数据串长度存放在42H单元，而它是RAM中的一个地址而不是值，所以要用访问到这个值是要进行（42H）的操作
	 MOV A,@R0;		设置数据指针R0，这样A就获得了数据串长度了
	 MOV R2,A;		把值的长度给R2暂存，为下面的循环相加次数做准备
	 CLR A;			清空A 
	 MOV R3,A;		清空R3 CLR不能直接清空寄存器内容所以CLR R3这种做法是错误的
ADD1:INC R0;		修改数据指针+1
	 ADD A,@R0;		累加
	 JNC NEXT;		处理进位，没有进位代码就转移到NEXT代码块
	 INC R3;		有进位的情况，高字节加1
NEXT:DJNZ R2,ADD1;	循环控制，判断数据是否全部加完了？如果是就继续执行，否则继续ADD1代码块工作
	 MOV 40H,A;		将累加结果低位存放到40H
	 MOV 41H,R3;	存放结果的高位，高位没有结果那就是0
	 RET
```

这个例子是一个单重循环，也就是只有一次套娃。

我们可以来个复杂点的，利用循环完成延时程序：

**🌰计算下面这个程序的执行时间**

```assembly
DELAY: MOV R6,#64H;		赋值,6*16+4=100
   I1: MOV R7,#0FFH;	赋值，000011111111B=255D
   I2: DJNZ R7,I2; 		DJNZ是寄存器的所记录的值减1后，如果不为零则进行程序转移到I2；否则就继续执行。
       DJNZ R6,I1;		DJNZ什么成分不用我多说了吧	？
       RET
```

我把每条指令的机器周期都标注一下：

|      源程序       | 指令周期 | 指令执行次数 |
| :---------------: | :------: | :----------: |
| DELAY: MOV R6,#64 |    1     |      1       |
| I1: MOV R7,#0FFH  |    1     |     100      |
|  I2: DJNZ R7, I2  |    2     |   100*255    |
|    DJNZ R6, I1    |    2     |     100      |
|        RET        |    2     |      1       |

如果知道时钟频率f_osc=12MHz的话，那么机器周期就是M=1us。这样就可以计算延时周期：
$$
t=(1*1+1*100+2*100*255+2*100+2*1)*M
\\=1+100+51000+200+2=51303\mu s=51.3ms
$$


### ⏰ 定时工作模式2

工作模式1和0都有一个问题，就是需要不断的重新赋值；
工作方式2有自动重新加载预设初值的操作，但代价就是计数范围减少，从2^16变成2^8。默认的情况下，使用TR0作为定时器。这种即使方式的特点是TH和TL赋予的值是相等的，不像前面的计时方式0和计时方式1一样需要分离出高八位和低五位并分别赋值。

先来一个简单的例子：

```assembly
MOV IE, #00H;
MOV TMOD,#02;
MOV TH, #0CEH;
MOV TL,#0CEH;
SETB TR0;
LOOP1:
		JBC TF0, LOOP2;
		AJMP LOOP1;
LOOP2:
		CPL P1.0;
		AJMP LOOP1;
```

另另外一个例子🌰:
用定时器1用工作方式2进行计数，每一百次进行累加器加1操作，按查询方式进行编程。
所谓查询方式就是

```assembly
MOV TL,#9CH;
MOV TH,#9CH;
MOV TMOD,#60H;
MOV IE,#00H;   		禁止中断
LOOP1:JBC TF1,LOOP2;
		AJMP LOOP1;
LOOP2:INC A;
		AJMP LOOP1;
```

另一个古老的例子🌰 :
周长2米，一圈产生一个下脉冲，从INT0进。30H，31H，32H分别是低、中、高位置

```assembly
		  ORG 0000H
0000H:  LJMP MAIN;
		   ORG 0003H;
0003H:  AJMP INT;
		   ORG #0040H;
MAIN: 	  MOV SP,#60H;
		  SETB EA;
		  SETB EX0;
	        SETB IT0;
		  MOV 30H,#00H;
		  MOV 31H,#01H;
		  MOV 32H,#02H;
HERE:   SJMP $
		ORG #0100H;
INT: 	push ACC;
		push PSW;
		MOV A,30H;
		ADD A,#2;
		MOV 30H,A;
		CLR A;
		ADDC A,31H;
		MOV 31H, A;
		CLR A;
		ADDC A,32H;
		MOV 32H,A;
		POP PSW;
		POP ACC;
		RETL
		END
```



